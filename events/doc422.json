{
  "start": 1577887200000,
  "duration": 50,
  "room": "K.1.105 (La Fontaine)",
  "title": "SaBRe: Load-time selective binary rewriting",
  "subtitle": "",
  "track": "Miscellaneous",
  "abstract": "<h2>Abstract</h2>\n\nBinary rewriting is a technique that consists in disassembling a program to modify its instructions, with\nmany applications, e.g. monitoring, debugging, reverse engineering and reliability. However, existing solutions suffer from well-known\nshortcomings in terms of soundness, performance and usability.\n\nWe present <em>SaBRe</em>, a novel load-time framework for selective binary rewriting. SaBRe rewrites specific constructs of\ninterest \u2014 mainly system calls and function prologues \u2014 when the program is loaded into memory. This enables users to intercept those constructs at runtime\nvia a modular architecture allowing custom plugins to be linked with SaBRe using a simple and flexible\nAPI. We also discuss the theoretical underpinnings of disassembling and rewriting, including conditions for\ncoverage, accuracy, and correctness; and how they affect SaBRe.\n\nWe developed two backends for SaBRe \u2014 one for x86_64 and one for RISC-V \u2014 which were in turn used to\nimplement two open-source plugins: a fast system call tracer and a fault injector. Our evaluation\nshows that SaBRe imposes little performance overhead, between 0.2% and 4.3% on average.\nIn addition to explaining the architecture of SaBRe and demonstrating its performance,\nwe also show on a concrete example how easy creating a new plugin for SaBRe is.\n\nSaBRe is a free open-source software released under the GPLv3 license\nand originally developed as part of the Software Reliabilty Group at Imperial College London.",
  "description": "<h2>Introduction</h2>\n\nThe goal of binary rewriting is to add, delete and replace\ninstructions in binary code. There are two main types of binary\nrewriting techniques: static and dynamic.\nIn static binary rewriting, the binary file is statically rewritten on disk, while\nin dynamic binary rewriting it is rewritten in memory, as the\nprogram executes.\n\nStatic binary rewriting has the advantage\nthat the rewriting process does not incur any overhead during\nexecution, as it is performed before the program starts running.\nHowever, static binary rewriting is hard to get right: creating a\nvalid modified executable on disk is challenging, and correctly\nidentifying all the code in the program is error-prone in the\npresence of variable-length instructions and indirect jumps.\n\nBy contrast, dynamic binary rewriting modifies the code in\nmemory, during program execution. This is typically accomplished by translating one basic block at a time and caching the\nresults, with branch instructions modified to point to already\ntranslated code. Since translation is done at runtime, when the\ninstructions are issued and the targets of indirect branches are\nalready resolved, dynamic binary rewriting does not encounter\nthe challenges discussed above for static binary rewriting.\nHowever, the translation is heavyweight and incurs a large\nruntime overhead.\n\nIn this presentation, we introduce SaBRe, a system that implements\na novel design point for binary rewriting. Unlike prior techniques, SaBRe operates at load-time, after the program is\nloaded into memory, but before it starts execution. Like static\nbinary rewriting techniques, SaBRe rewrites the code in-place,\nbut the translation is done in memory, as for dynamic binary\nrewriting. To achieve a high level of both performance and reliability,\nSaBRe relies by default on trampolines, which are extremely efficient\nand can be used more than 99.99% of the time, and only falls back\non illegal instructions triggering a signal handler for pathological\ncases.\n\nThe main limitation of SaBRe is that it is designed\nto rewrite only certain types of constructs, namely system\ncalls (including vDSO), function prologues and some architecture-\nspecific instructions (e.g. RDTSC in x86). However, as we illustrate\nlater on, this is enough to support a variety of tasks, with\nmuch lower overhead than with dynamic binary rewriting and\nwithout incurring the precision limitations of static binary\nrewriting.\n\nWe implemented two binary rewriters based on this design:\none for x86 64 and one for RISC-V code. Both rewriters\nfeature a flexible API, which we used to implement three\ndifferent plugins: a fast system call tracer, a multi-version\nexecution system (not open-sourced yet) and a fault injector.\nIn summary, our main contributions are:\n1. A new design point for selective binary rewriting which\ntranslates code in memory in-place at load time, before\nthe program starts execution.\n2. An implementation of this approach for two architectures, one for x86 64 and the other for RISC-V.\n3. A comprehensive evaluation using two open-source plugins: a fast <code>strace</code>-like\nsystem call tracer and a fault injector.\n4. An extremely simple API that can be leveraged by users to\nimplement and integrate their own plugins.",
  "persons": [
    "Paul-Antoine Arras"
  ]
}