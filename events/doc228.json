{
  "start": 1577895000000,
  "duration": 30,
  "room": "K.3.401",
  "title": "Retro music - Open Cubic Player",
  "subtitle": "",
  "track": "Retrocomputing",
  "abstract": "This presentation includes multiple topics mixed together\n * Porting a DOS multimedia program into Linux/BSD\n * How music was composed/stored in old type of games from the 8bit era, up into the amiga (and partly the DOS world)\n * How does audio/music hardware work. C64 SID, ZX-Spectrum and alike, Amiga, Adlib FM-synth OPL2/3 and General Midi",
  "description": "As a child, I was exposed to Cubic Player. This program was a text-based music player. All the colors mesmerized me and it gave a Direct visual feedback of how the music was generated.\n\n\n\nDuring teenage years I learned programming and got curiousity for Linux. All the sourcecode for everything was available. The kernel, multimedia libraries, multimedia tools. If there are anything you wonder how works, you can inspect it. You are unable to sort how a specific detail can be done in your own project, try to find another project that has done something similiar! But for playing this amiga style modules, there was no programs that had the same charm as Cubic Player. Programs like mikmod, XMMS, Audacious only displayed playlist, maybe instrument-names and maybe an spectrum analyzer.\n\n\n\nThen I discovered that Cubic Player had been released as Open Cubic Player - but nobody had touched it. Releasing a project does not automatically make it work in other systems. But it makes it possible. I grabbed the source code and started to study it. All of it was based on direct hardware access, as it was written for DOS. Direct access to video-memory/hardware, raw keyboard scan codes, hardware interrupts for timers allowing background rendering of audio if needed etc. A natural candidate for a novice programmer to port?\n\nSlowly I went through one and one single file of the original source code.\n* Lots of logic could be kept (just needed type fixing like replacing byte with uint8_t, a char is not guaranteed to be unsigned)\n* Some could be thrown away like direct audio hardware drivers\n* Some needed heavy rewrites like video output. The code already was abstracted with having functions for mixing colors and text rendering.\n* Assembler inlines took many weeks - months (watcom c++ and gcc has VERY different syntax and integration)\n* The timer interrupt was solved using SIGTIMER. But porting the code caused a zero-day kernel bug to be discovered https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-0554\n* Text output was originally solved using ncurses\n* Filenames are not 8.3 format in Linux/BSD\n\nWhen text appears on the screen, and audio (highly distorted in the beginning) appeared, was a magical feeling. Progress was faster when the goal felt to be well within the reach.\n\nWhen you the make your code public, people start to use it... and you start to get feedback like:\n* Program is unable to compile on other platforms - assembler inlines is not portable - even when compiling for x86_64 - got to make C-replacement for all of them - A person submitted the full rework of the floating point version of the mixer from assembler into C!!! WOW\n* Nothing works when compiling for MacOS - Wait, you tried what? Endian is important when parsing binary file formats\n* Specific crashes that only happens for some few people - compiler bugs (these were more common back in the days)\n\n\n\nMusic formats time, and their integration!\n\nSo, what is a amiga style module?\n\nLet's take a look at the Amiga hardware. The sound-chip there is a 4 channel wave-mixer. Each channel is assigned a PCM audio source, volume and a wide range of possible samplerates. These three parameters can be adjusted anytime.\nAn Amiga style module is then a set of audio PCM (8bit) samples - a sound font, and then 4 tracks recipe of how these 3 parameters should be manipulated. These can be small adjustements, big adjustments, slow or fast - All imitating different kind of effects from playing real life instruments.\nPortamento - sliding between seminotes - sliding the finger on the strings along the neck of the guitar\nTremolo - small vibration of the pitch - tremolo arm on an electric guitar\n...\nWhen this later moved into the computer world, the entire mixer had to be done in software, the number of channels was no longer limited by the hardware mixer.\n....\nVarious editors, players, file-format tools etc. all do things slighly different. The exact result for a given file will have variations, but the overall impression should be the same. The most important reason why music was done in this format was file sizes. A typical song would be in the range 10-100 kilobyte only, and the same mixer/playback-routines can be used for playing the game sound-effects. The complete code needed for rendering a given fileformat is not very large.\n\nSo, what if we can ditch the soundfont in the files to save space. Welcome to General Midi. General Midi defines a set of instruments - actually a full orchestra and a bunch of synth style sounds. But it only defines what they are, not the exact sounds. An electric guitar is not just a guitar. And a MIDI file contains a set of \"note-on including attack\", \"note-off\" and \"select instrument\" events on a timeline.\n\nOpen Cubic Player had support for General Midi, and parsing of soundfont in a single file format: UltraSound DOS driver fileformat. The few ones you found online were mostly propetiary - not very compatible with open source. So people kept demanding support for more formats. So I made a parser for the timidity config files; so far good enough. Then it kept a forever race and need for new features discovered in these configuration files - and even worse - depending on parsing binary fileformats that might contain the needed samples. Eventually - as the sole maintainer of the project - throw out the entire midi parser and renderer, and just use the entire Timidity+ project almost as-is. There is no point in re-inventing the wheel if you do not intend to improve it. So currently the MIDI renderer in Open Cubic Player is (a fork of) Timidity+.\n\nSame for the MP2/MP3 renderer that was using the original AMP engine. Instead of trying to fix it - use libmad!\n\nOgg Vorbis files - libogg\n\nFLAC files - libflac\n\nAnd then users starts to request support for other fileformats - luckily, integration of them are not so hard when there is open source libraries and players that can be used.\n\nC64 .SID files - libsidplay\n\nZX-Spectrum 128 .AY files - Code chopped out from \"aylet\"\n\nAtari ST .YM files - Using a fork of STYMulator\n\nOPL2/OPL3 style - libadplug\n\nAHX Tracker / Hively Tracker - Hively Tracker source contains a .wav file renderer",
  "persons": [
    "Stian Sebastian Skjelstad"
  ]
}