{
  "start": 1577889000000,
  "duration": 25,
  "room": "UB2.252A (Lameere)",
  "title": "Asyncio: understanding async and await in Python",
  "subtitle": "",
  "track": "Python",
  "abstract": "<p>Often when asyncio is discussed, people think of it as a high performance concurrency programming paradigm for Python. In this talk however, we approach asyncio from a different angle, one that will possibly help some of you to finally get what asyncio is about. it's not only about performance, but at least as much about correctness and readability of concurrent applications.</p>",
  "description": "<p>Concurrency is hard to get right.</p>\n\n<p>Often when asyncio is discussed, people think of it as a high performance concurrency programming paradigm for Python. In this talk however, we approach asyncio from a different angle, one that will possibly help some of you to finally get what asyncio is about. it's not only about performance, but at least as much about correctness and readability of concurrent applications.</p>\n\n<p>It is known that for multithreaded applications, synchronization is hard to get right. Doing it wrong can either lead to deadlocks or broken data structures.</p>\n\n<p>We will have a look at how using asyncio is different from using threads, when it's better and what pitfalls we have.</p>\n\n<p>This talk should be a good introduction for anyone just starting with asyncio, but can also clarify things for people that are using asyncio already. I expect people to have at least used some form of concurrency, either threads or an event loop like we have in JavaScript.</p>",
  "persons": [
    "Jonathan Slenders"
  ]
}