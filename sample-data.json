[
  {
    "title": "Back to Basics: Const as a Promise",
    "speakers": ["Dan Saks"],
    "description": [
      "The const qualifier has various uses in C++. One of the most valuable uses is in declaring function headings that constrain the effects of function calls. Using const appropriately can reduce bugs and development time by turning potential run-time errors into compile-time errors that are much easier to find and correct. Using const can even reduce your program’s code size and execution time.",
      "Despite these benefits, too many C++ programmers still use const reactively rather than proactively. That is, they tend to add const as needed to quell compiler error messages, rather than design const in as they code. To get the most out of const, programmers really need to understand (1) when and where to place const in declarations, (2) when to leave it out entirely, and (3) how type conversions involving const behave.",
      "The key insight about const is to understand const as a promise—a promise not to modify something. This session explains the real meaning of that promise and how that insight can guide you in declaring function parameters and return types. It also explains why you shouldn’t declare by-value parameters and return types as const, why overloading on const is such a useful and ubiquitous idiom, and why it is meaningful to declare constexpr member functions as const."
    ],
    "duration": 60,
    "location": [
      "Gaylord Rockies Resort & Convention Center",
      "Aurora",
      "Colorado",
      "United States"
    ]
  },

  {
    "title": "When C++ Style Guides Contradict",
    "speakers": ["Nicolai Josuttis"],
    "description": [
      "C++ is a success story. One reason is its backward compatibility. But that also makes C++ more or more unteachable. Too many features, too many rules, too many inconsistences.",
      "So, the only solution (beside clean-ups for simple rules) are good style guides. However, these style guides contradict significantly. For example, while some recommend to define operations as non-member non-friend, others recommend to use hidden friends. Or when should we define virtual destructors? Or the details of the rule of 0, 3, 5, \"5 or 3\". Or how to initialize an object.",
      "I have no clear solution. But it's time to open the stage for a consolidation of the situation. At least in the interest of all the average programmers who do not know all the rules (well, yes, nobody does)."
    ],
    "when": "2019-09-16T15:15:00+00:00",
    "duration": 60,
    "location": [
      "Gaylord Rockies Resort & Convention Center",
      "Aurora",
      "Colorado",
      "United States"
    ]
  },

  {
    "title": "Concurrency in C++20 and Beyond",
    "speakers": ["Anthony Williams"],
    "description": [
      "C++20 is set to add new facilities to make writing concurrent code easier. Some of them come from the previously published Concurrency TS, and others are new, but they all make our lives as developers easier. This talk will introduce the new features, and explain how and why we should use them.",

      "The evolution of the C++ Concurrency support doesn't stop there though: the committee has a continuous stream of new proposals. This talk will also introduce some of the most important of these, including the new Executor model."
    ],
    "when": "2019-09-17T16:45:00+00:00",
    "duration": 60,
    "location": [
      "Gaylord Rockies Resort & Convention Center",
      "Aurora",
      "Colorado",
      "United States"
    ]
  }
]
